/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use std::io::prelude::*;
use std::{
    env,
    collections::HashMap,
    convert::TryFrom, convert::TryInto,
    fs::File,
    path::{Path, PathBuf},
};

use anyhow::bail;
use anyhow::Result;

pub mod types;


pub fn generate_component_scaffolding(idl_file: &str) {
    println!("cargo:rerun-if-changed={}", idl_file);
    let idl = slurp_file(idl_file).unwrap();
    let component = types::ComponentInterface::new_from_str(&idl).unwrap();
    // XXX TODO: give the output file a unique name related to the input file.
    let mut filename = Path::new(idl_file).file_stem().unwrap().to_os_string();
    filename.push(".uniffi.rs");
    let mut out_file = PathBuf::from(env::var("OUT_DIR").unwrap());
    out_file.push(filename);
    let mut f = File::create(out_file).unwrap();
    GenerateScaffolding::generate(&component, &mut f);
}

fn slurp_file(file_name: &str) -> Result<String> {
    let mut contents = String::new();
    let mut f = File::open(file_name)?;
    f.read_to_string(&mut contents)?;
    Ok(contents)
}

trait GenerateScaffolding: std::fmt::Debug {
    fn generate(&self, f: &mut File) -> Result<()> {
        bail!("can't generate from {:?}", self);
    }
    fn generate_toplevel(&self, f: &mut File) -> Result<()> {
        bail!("can't generate toplevel item from {:?}", self);
    }
    fn generate_extern_function_declaration(&self, f: &mut File) -> Result<()> {
        bail!("can't generate extern function declaration from {:?}", self);
    }
    fn generate_argument_declaration(&self, f: &mut File) -> Result<()> {
        bail!("can't generate argument declaration from {:?}", self);
    }
    fn ffi_type(&self) -> Result<String> {
        bail!("can't get ffi_type for {:?}", self);
    }
}

impl GenerateScaffolding for types::ComponentInterface {
    fn generate(&self, f: &mut File) -> Result<()> {
        writeln!(f, "// This file was autogenerated by some hot garbage in the `uniffi` crate.")?;
        writeln!(f, "// Trust me, you don't want to mess with it!")?;
        for m in &self.members {
            match m {
                types::InterfaceMember::Object(obj) => obj.generate_toplevel(f)?,
                types::InterfaceMember::Record(rec) => rec.generate_toplevel(f)?,
                types::InterfaceMember::Enum(e) => e.generate_toplevel(f)?,
            }
        }
        writeln!(f, "")?;
        writeln!(f, "deliberate syntax error")?;
        Ok(())
    }
}

impl GenerateScaffolding for types::ObjectType {
    fn generate_toplevel(&self, f: &mut File) -> Result<()> {
        writeln!(f, "")?;
        writeln!(f, "lazy_static::lazy_static! {{")?;
        writeln!(f, "  static ref UNIFFI_HANDLE_MAP_{name}: ConcurrentHandleMap<{name}> = ConcurrentHandleMap::new();", name=self.name)?;
        writeln!(f, "}}")?;
        writeln!(f, "")?;
        self.members.iter().try_for_each(|m| {
            m.generate_extern_function_declaration(f)
        })?;
        writeln!(f, "}}");
        Ok(())
    }
}

impl GenerateScaffolding for types::ObjectTypeMember {
    fn generate_extern_function_declaration(&self, f: &mut File) -> Result<()> {
        match self {
            types::ObjectTypeMember::Constructor(c) => c.generate_extern_function_declaration(f)?,
            types::ObjectTypeMember::Method(m) => m.generate_extern_function_declaration(f)?,
        };
        Ok(())
    }
}

impl GenerateScaffolding for types::ObjectTypeConstructor {
    fn generate_extern_function_declaration(&self, f: &mut File) -> Result<()> {
        writeln!(f, "#[no_mangle]")?;
        writeln!(f, "pub extern \"C\" fn {}(", &self.ffi_name())?;
        self.argument_types.iter().try_for_each(|arg| {
            arg.generate_argument_declaration(f)
        })?;
        writeln!(f, "  err: &mut ExternError,")?;
        writeln!(f, ") -> u64 {{")?;
        writeln!(f, "  log::debug!(\"{}\");", self.ffi_name())?;
        writeln!(f, "  UNIFFI_HANDLE_MAP_{}.insert_with_output(err, || {{", self.ffi_name())?;
        self.argument_types.iter().try_for_each(|arg| {
            writeln!(f, "    // TODO: prepare arg {}", &arg.name)
        })?;
        writeln!(f, "    FirefoxAccount::new(")?; // XXX TODO: get rust name from object, not hardcode
        self.argument_types.iter().try_for_each(|arg| {
            writeln!(f, "      // TODO: pass arg {}", &arg.name)
        })?;
        writeln!(f, "    )")?;
        writeln!(f, "  }})")?;
        writeln!(f, "}}")?;
        writeln!(f, "")?;
        Ok(())
    }
}

impl GenerateScaffolding for types::ObjectTypeMethod {
    fn generate_extern_function_declaration(&self, f: &mut File) -> Result<()> {
        writeln!(f, "#[no_mangle]")?;
        writeln!(f, "pub extern \"C\" fn {}(", &self.ffi_name())?;
        writeln!(f, "  handle: u64,")?;
        self.argument_types.iter().try_for_each(|arg| {
            arg.generate_argument_declaration(f)
        })?;
        writeln!(f, "  err: &mut ExternError,")?;
        match &self.return_type {
            Some(t) => {
                writeln!(f, ") -> {} {{", t.ffi_type()?)?;
            },
            None => {
                writeln!(f, ") {{")?;
            }
        }
        writeln!(f, "  log::debug!(\"{}\");", self.ffi_name())?;
        // XXX TODO: allow annotations to decide between call_mut, call, etc.
        // XXX TODO: no really, get the class name from the object by appropriate lookup magic.
        writeln!(f, "  UNIFFI_HANDLE_MAP_FirefoxAccount.call_with_result_mut(err, handle, |obj: &mut FirefoxAccount| {{")?;
        self.argument_types.iter().try_for_each(|arg| {
            writeln!(f, "    // TODO: prepare arg {}", &arg.name)
        })?;
        writeln!(f, "    obj.{}(", self.name)?;
        self.argument_types.iter().try_for_each(|arg| {
            writeln!(f, "      // TODO: pass arg {}", &arg.name)
        })?;
        writeln!(f, "    )")?;
        writeln!(f, "  }})")?;
        writeln!(f, "}}")?;
        writeln!(f, "")?;
        Ok(())
    }
}

impl GenerateScaffolding for types::ObjectTypeArgument {
    fn generate_argument_declaration(&self, f: &mut File) -> Result<()> {
        writeln!(f, "  arg: &str, ");
        Ok(())
    }
}
impl GenerateScaffolding for types::RecordType {
    fn generate_toplevel(&self, f: &mut File) -> Result<()> {
        writeln!(f, "// Record {}", self.name);
        Ok(())
    }
}

impl GenerateScaffolding for types::EnumType {
    fn generate_toplevel(&self, f: &mut File) -> Result<()> {
        writeln!(f, "// Enum {}", self.name);
        Ok(())
    }
}

impl GenerateScaffolding for types::TypeReference {
    fn ffi_type(&self) -> Result<String> {
        Ok("hello".to_string())
    }
}