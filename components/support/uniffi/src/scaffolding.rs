/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

use std::io::prelude::*;
use std::{
    env,
    collections::HashMap,
    convert::TryFrom, convert::TryInto,
    fs::File,
    path::{Path, PathBuf},
};

use anyhow::bail;
use anyhow::Result;

use super::types;

pub trait GenerateScaffolding: std::fmt::Debug {
    fn generate(&self, f: &mut File) -> Result<()> {
        bail!("can't generate from {:?}", self);
    }
    fn generate_toplevel(&self, f: &mut File) -> Result<()> {
        bail!("can't generate toplevel item from {:?}", self);
    }
    fn generate_extern_function_declaration(&self, f: &mut File) -> Result<()> {
        bail!("can't generate extern function declaration from {:?}", self);
    }
    fn generate_argument_declaration(&self, f: &mut File) -> Result<()> {
        bail!("can't generate argument declaration from {:?}", self);
    }
    fn generate_argument_preparation(&self, f: &mut File) -> Result<()> {
        bail!("can't generate argument preparation from {:?}", self);
    }
    fn ffi_type(&self) -> Result<String> {
        bail!("can't get ffi_type for {:?}", self);
    }
    fn ffi_prepare_method(&self) -> Result<String> {
        bail!("can't get ffi_prepare_method for {:?}", self);
    }
}

impl GenerateScaffolding for types::ComponentInterface {
    fn generate(&self, f: &mut File) -> Result<()> {
        writeln!(f, "// This file was autogenerated by some hot garbage in the `uniffi` crate.")?;
        writeln!(f, "// Trust me, you don't want to mess with it!")?;
        writeln!(f, "use ffi_support::{{
    define_bytebuffer_destructor, define_handle_map_deleter, define_string_destructor, ByteBuffer,
    ConcurrentHandleMap, ExternError, FfiStr,
}};
        ")?;
        for m in &self.members {
            match m {
                types::InterfaceMember::Object(obj) => obj.generate_toplevel(f)?,
                types::InterfaceMember::Record(rec) => rec.generate_toplevel(f)?,
                types::InterfaceMember::Enum(e) => e.generate_toplevel(f)?,
            }
        }
        writeln!(f, "")?;
        Ok(())
    }
}

impl GenerateScaffolding for types::ObjectType {
    fn generate_toplevel(&self, f: &mut File) -> Result<()> {
        writeln!(f, "")?;
        writeln!(f, "lazy_static::lazy_static! {{")?;
        writeln!(f, "  static ref UNIFFI_HANDLE_MAP_{name}: ConcurrentHandleMap<{name}> = ConcurrentHandleMap::new();", name=self.name)?;
        writeln!(f, "}}")?;
        writeln!(f, "")?;
        self.members.iter().try_for_each(|m| {
            m.generate_extern_function_declaration(f)
        })?;
        writeln!(f, "
define_handle_map_deleter!(UNIFFI_HANDLE_MAP_{name}, fxa_free,);
define_string_destructor!(fxa_str_free);
define_bytebuffer_destructor!(fxa_bytebuffer_free);
        ", name=self.name)?;
        Ok(())
    }
}

impl GenerateScaffolding for types::ObjectTypeMember {
    fn generate_extern_function_declaration(&self, f: &mut File) -> Result<()> {
        match self {
            types::ObjectTypeMember::Constructor(c) => c.generate_extern_function_declaration(f)?,
            types::ObjectTypeMember::Method(m) => m.generate_extern_function_declaration(f)?,
        };
        Ok(())
    }
}

impl GenerateScaffolding for types::ObjectTypeConstructor {
    fn generate_extern_function_declaration(&self, f: &mut File) -> Result<()> {
        writeln!(f, "#[no_mangle]")?;
        writeln!(f, "pub extern \"C\" fn {}(", &self.ffi_name())?;
        self.argument_types.iter().try_for_each(|arg| {
            arg.generate_argument_declaration(f)
        })?;
        writeln!(f, "  err: &mut ExternError,")?;
        writeln!(f, ") -> u64 {{")?;
        writeln!(f, "  log::debug!(\"{}\");", self.ffi_name())?;
        writeln!(f, "  UNIFFI_HANDLE_MAP_{}.insert_with_output(err, || {{", self.ffi_name())?;
        self.argument_types.iter().try_for_each(|arg| {
            arg.generate_argument_preparation(f)
        })?;
        writeln!(f, "    FirefoxAccount::new(")?; // XXX TODO: get rust name from object, not hardcode
        self.argument_types.iter().try_for_each(|arg| {
            writeln!(f, "      {},", arg.ffi_name())
        })?;
        writeln!(f, "    )")?;
        writeln!(f, "  }})")?;
        writeln!(f, "}}")?;
        writeln!(f, "")?;
        Ok(())
    }
}

impl GenerateScaffolding for types::ObjectTypeMethod {
    fn generate_extern_function_declaration(&self, f: &mut File) -> Result<()> {
        writeln!(f, "#[no_mangle]")?;
        writeln!(f, "pub extern \"C\" fn {}(", &self.ffi_name())?;
        writeln!(f, "  handle: u64,")?;
        self.argument_types.iter().try_for_each(|arg| {
            arg.generate_argument_declaration(f)
        })?;
        writeln!(f, "  err: &mut ExternError,")?;
        match &self.return_type {
            Some(t) => {
                writeln!(f, ") -> {} {{", t.ffi_type()?)?;
            },
            None => {
                writeln!(f, ") {{")?;
            }
        }
        writeln!(f, "  log::debug!(\"{}\");", self.ffi_name())?;
        // XXX TODO: allow annotations to decide between call_mut, call, etc.
        // XXX TODO: no really, get the class name from the object by appropriate lookup magic.
        writeln!(f, "  UNIFFI_HANDLE_MAP_FirefoxAccount.call_with_result_mut(err, handle, |obj: &mut FirefoxAccount| {{")?;
        self.argument_types.iter().try_for_each(|arg| {
            writeln!(f, "    // TODO: prepare arg {}", &arg.name)
        })?;
        writeln!(f, "    obj.{}(", self.name)?;
        self.argument_types.iter().try_for_each(|arg| {
            writeln!(f, "      // TODO: pass arg {}", &arg.name)
        })?;
        writeln!(f, "    )")?;
        writeln!(f, "  }})")?;
        writeln!(f, "}}")?;
        writeln!(f, "")?;
        Ok(())
    }
}

impl GenerateScaffolding for types::ObjectTypeArgument {
    fn generate_argument_declaration(&self, f: &mut File) -> Result<()> {
        writeln!(f, "  {}: {}, ", self.ffi_name(), self.ffi_type()?)?;
        Ok(())
    }
    fn generate_argument_preparation(&self, f: &mut File) -> Result<()> {
        writeln!(f, "    let {name} = ({name}{method});", name=self.ffi_name(), method=self.ffi_prepare_method()?)?;
        Ok(())
    }
    fn ffi_type(&self) -> Result<String> {
        self.typ.ffi_type()
    }
    fn ffi_prepare_method(&self) -> Result<String> {
        self.typ.ffi_prepare_method()
    }
}

impl GenerateScaffolding for types::RecordType {
    fn generate_toplevel(&self, f: &mut File) -> Result<()> {
        writeln!(f, "// Record {}", self.name)?;
        Ok(())
    }
}

impl GenerateScaffolding for types::EnumType {
    fn generate_toplevel(&self, f: &mut File) -> Result<()> {
        writeln!(f, "// Enum {}", self.name)?;
        Ok(())
    }
}

impl GenerateScaffolding for types::TypeReference {
    fn ffi_type(&self) -> Result<String> {
        Ok(match &self {
            types::TypeReference::Boolean => "u8".to_string(), // N.B. it's not safe to use actual bools in the FFI, for reasons (*cough* JNA *cough*)
            types::TypeReference::String => "FfiStr<'_>".to_string(),
            _ => "NotDoneYet".to_string()
        })
    }
    fn ffi_prepare_method(&self) -> Result<String> {
        Ok(match &self {
            types::TypeReference::Boolean => " != 0".to_string(),
            types::TypeReference::String => ".as_str()".to_string(),
            _ => "NotDoneYet".to_string()
        })
    }
}
